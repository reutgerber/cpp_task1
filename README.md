322516840
reutgerber@gmail.com

יצרתי מחלקה GRAPH 
לכל אובייקט במחלקה יש את השדות הפרטיים:
מספר קודקודים
מספר צלעות
מטריצת שכנויות
אילו קודקודים ביקרנו
האם סימטרי (כלומר אם המטריצה המייצגת את הגרף סימטרית-הגרף מכוון).

המחלקה מממשת את הפונקציות:
א) CHECKSYMETRIC-בודקת על פי מטריצת השכנויות האם המטריצה סימטרית או לא ומעדכנת את המשתנה הבוליאני SYMETRIC.
ב) LOADGRAPH-מקבלת מטריצת שכנויות ומעדכנת את המטריצת שכנויות של האובייקט, קוראת לCHECKSYMETRIC
ג) WEIGHT-מקבלת שני קודקודים ומחזירה את המשקל ביניהם בעזרת מטריצת השכנויות של האובייקט.
ד)CONNECTED- מקבלת שני קודקודים מחזירה אם יש ביניהם צלע, כלומר אם המשקל ביניהם שונה מ0.
ה)PRINTGRAPH-מדפיס את מספר הקודקודים ומספר הצלעות בגרף

מחלקה EDGES
עם השדות:
מ-M מבנה נתונים מסוג מפה, מפתח-זוג קודקודים המחברים את הצלע ערך-בולינאני
האם מכוון-ISDIRECTED-משתנה בוליאני- האם הצלע שייכת לגרף מכוון או לא.

המחלקה מממשת את הפונקציות:
א) ADD-מקבלת 2 קודקודים ומוסיפה אותם כ"צמד" למפה של האובייקט.
ב) CONTAINS-בודק האם זוג קודקודים מוכלים ב"MAP" של האובייקט.
ג) REMOVE-מקבל 2 קודקודים ומוחק אותם מהמפה של האובייקט.

מחלקה NEIGHBOR
שדות:
מספר
משקל
כלומר מייצג שכן של קודקוד- מספר הקודקוד והמשקל בין הקודקוד לשכן.

מחלקה VERTEX
שדות:
מספר
מרחק
קודם
וקטור מסוג שכן.

המחלקה מממשת את הפונקציות:
א)VERTEX מאתחלת לכל קודקוד את המספר, את המרחק ואת הקודם.
ב) ADD_NEIGHBOR מכניס לרשימת השכנים של האובייקט שכן חדש.
ג)SET_PREV מעדכן את הקודם של האובייקט לפי מה שהפו' מקבלת.
ד)GET_PREV מחזירה את הקודם של האובייקט.
ה)SET_DISTANCE- מעדכן את המרחק לפי מה שהפו' מקבלת

לאחר שהגדרנו את האובייקטים הנחוצים נעבור להסבר על הקובץ "ALGORITHMS.CPP".
קובץ זה מממש את המתודות המוצהרות בקובץ ALGORITHMS.HPP

פונקציות העזר:
א) IN_VECT-בודקת האם קודקוד נמצא בוקטור
ב) FILL_NEIGHBERS- מקבלת אובייקט מסוג גרף וכתובת של וקטור על וקטור. הפונקציה עוברת על כל קודקוד בגרף ומממלאת בוקטור שקיבלנו את השכנים של כל קודקוד.
ג) DFS-מקבל קודקוד מסמן שביקרנו בו קורא שוב לפונקציה עם כל שכן שלו.
ד) PRINT_PATH-מקבלת וקטור ומדפיסה אותו.
ה) DFS_NEGATIVE-רעיון האלגוריתם- מתחילים לבדוק מקודקוד ההתחלתי, נסמן שביקרנו בו ונכניס אותו למחסנית. עוברים על כל שכן שלו, אם עוד לא ביקרנו בו נוסיף צלע ונסמן שביקרנו בו ונקרא שוב לפונקציה הפעם ההתחלתי הוא השכן. 
אחרת, כבר ביקרנו בו כלומר יש מעגל. נכניס אותו למחסנית. באמצעות פונקציית עזר נחשב את המשקל של מסלול המעגל. אם המשקל חיובי נמשיך. אחרת נסמן שסיימנו.
ה) DFS_CYCLE-
רעיון האלגוריתם- מתחילים לבדוק מקודקוד ההתחלתי, נסמן שביקרנו בו ונכניס אותו למחסנית. עוברים על כל שכן שלו, אם עוד לא ביקרנו בו נוסיף צלע ונסמן שביקרנו בו ונקרא שוב לפונקציה הפעם ההתחלתי הוא השכן. 
אחרת, כבר ביקרנו בו כלומר יש מעגל. נכניס אותו למחסנית. נסמן במשתנה בוליאני שסיימנו.
ו)CALC_PATH_WEIGHT- הפונקציה מחזירה משקל של מסלול המיוצג באמצעות מחסנית. 
ז)DFS- פונקציית העמסה. הפונקצייה מקבלת קודקוד התחלתי, צבע, וקטור של צבעים, וקטור של שכנים. תחילה הפונקצייה צובעת את הקודקוד ההתחלתי (במקרה שלי החלטתי שהצבע יהיה 1). עבור כל שכן של הקודקוד: אם הוא כבר צבוע נחזיר "FALSE". אם הוא לא צבוע וגם נעשה עליו DFS עם הצבע השני (-1) וקיבלנו FALSE, נחזיר "FALSE".
אם סיימנו את הקריאות הרקורסיביות ולא הוחזר "FALSE", נחזיר "TRUE".
 

פונקציות עיקריות אופן המימוש:
א) IS_NEGATIVE_CYCLE-מעדכן את וקטור השכנים ואת וקטור הביקורים באמצעות פונקציות עזר.
קורא לפונקציית העזר DFS_NEGATIVE המעדכנת את המשתנה הבוליאני "FINISHED" כלומר יש מעגל ואת המחסנית ממלאת בקודקודי המעגל.
אם "FINISHED" הפונקציה תשתמש בפונקציות העזר לחשב את המשקל של המעגל ולהדפיס את המסלול. הפונקציה תחזיר "TRUE".
אחרת הפונקציה תחזיר "FALSE".
ב) IS_CONTAINS_CYCLE-מעדכן את וקטור השכנים ואת וקטור הביקורים באמצעות פונקציות עזר.
קורא לפונקציית העזר DFS_CYCLE המעדכנת את המשתנה הבוליאני "FINISHED" כלומר יש מעגל ואת המחסנית ממלאת בקודקודי המעגל.
אם "FINISHED" הפונקציה תשתמש בפונקציות העזר לחשב את המשקל של המעגל ולהדפיס את המסלול. הפונקציה תחזיר "TRUE".
אחרת הפונקציה תחזיר "FALSE".
ג) IS_CONNECTED-תחילה הפונקצייה מעדכנת את וקטור השכנים ואת וקטור הביקורים באמצעות פונקציית העזר.
נעבור בלולאה חיצונית על כל קודקוד בגרף ונבצע עליו DFS. פונקציית העזר הנ"ל תעדכן את וקטור הביקורים. נעבור בלולאה פנימית על כל הקודקודים, אם יש קודקוד שלא ביקרנו בו הפונקציה תחזיר 0. אם סיימנו לעבור על הלולאה החיצונית הפונקציה תחזיר 1.
ד) SHORTEST_PATH- מימשתי באמצעות האלגוריתם בלמן פורד.
ה)IS_BIPARTITE- נגדיר משתנה בוליאני "BIPARTITE" נאתחל אותו ב"TRUE". נעבור בלולאה על כל הקודקודים בגרף. על כל קודקוד נעשה DFS אם הDFS החזיר FALSE נעדכן את המשתנה הבוליאני ב"FALSE".
אם בסיום הלולאה המשתנה הבוליאני נשאר TRUE זה אומר שהגרף אכן דו-צדדי ונרצה להדפיס את הקבוצות.
ניצור 2 וקטורים לכל קבוצה. נעבור בלולאה על מערך הצבעים. עבור כל קודקוד אם הצבע שווה 1 נכניס אותו למערך A. אחרת נכניס אותו למערך B. נכניס לתוך STRING את הקבוצות שקיבלנו ונחזיר את הSTRING.
